---
description: CRITICAL RULE - Test-Driven Development (TDD) core methodology. Red-Green-Refactor cycle and fundamental principles.
globs: ["*.cpp", "*.h"]
alwaysApply: true
priority: 4
---

# üß™ Test-Driven Development (TDD) - Core

## üéØ Objetivo

**ALWAYS** seguir o paradigma Test-Driven Development (TDD) para c√≥digo cr√≠tico e reutiliz√°vel, garantindo que testes sejam escritos **ANTES** da implementa√ß√£o, seguindo o ciclo **Red-Green-Refactor**.

## üö® REGRA PRINCIPAL - TEST-FIRST üö®

**ALWAYS** escrever testes **ANTES** da implementa√ß√£o quando:

- ‚úÖ **Criando nova fun√ß√£o helper/utility** (em `Utils/` ou `Helpers/`)
- ‚úÖ **Implementando l√≥gica de neg√≥cio** (c√°lculos, valida√ß√µes, transforma√ß√µes)
- ‚úÖ **Criando novos motores** (`*Motor.cpp` - PointBuy, Multiclass, RaceBonus)
- ‚úÖ **Criando novos validators** (`*Validator.cpp`)
- ‚úÖ **Adicionando c√°lculos complexos** (modificadores, profici√™ncias, atributos)
- ‚úÖ **Implementando regras de neg√≥cio** (regras D&D, multiclassing, point buy)
- ‚úÖ **Refatorando c√≥digo cr√≠tico** (escrever testes primeiro para garantir comportamento)

**NEVER** implementar c√≥digo cr√≠tico sem testes correspondentes.

## üîÑ O Ciclo Red-Green-Refactor

### 1. Red: Escrever Teste que Falha

**ALWAYS** come√ßar escrevendo o teste que define o comportamento esperado:

```cpp
// ‚úÖ CORRETO - Teste primeiro
BEGIN_DEFINE_SPEC(FPointBuyMotorSpec, "MyProject2.CreateSheet.PointBuy",
                  EAutomationTestFlags::ProductFilter | EAutomationTestFlags::ApplicationContextMask)
    FPointBuyMotor* Motor;
END_DEFINE_SPEC(FPointBuyMotorSpec)

void FPointBuyMotorSpec::Define()
{
    Describe("CalculatePointBuyCost", [this]()
    {
        It("deve calcular custo correto para score 15 (9 pontos)", [this]()
        {
            // Arrange
            int32 Score = 15;

            // Act
            int32 Result = FPointBuyMotor::CalculatePointBuyCost(Score);

            // Assert
            TestEqual("Custo para score 15 deve ser 9", Result, 9);
        });
    });
}
```

**Por que come√ßar pelo teste:**
- Define o contrato antes da implementa√ß√£o
- For√ßa pensar na interface primeiro
- Garante que o teste pode detectar erros
- Confirma que a infraestrutura de teste funciona

**üö® REGRA CR√çTICA: Teste NUNCA Pode Ter L√≥gica Interna**

> **"Se voc√™ pode remover a fun√ß√£o sendo testada e o teste ainda passa, o teste est√° errado."**

**ALWAYS seguir estes princ√≠pios:**

1. **Teste usa mocks para simular dados** - N√ÉO para implementar l√≥gica
2. **Teste envia dados para m√≥dulo oficial** - Sempre chama a fun√ß√£o real
3. **Teste n√£o resolve por si s√≥** - N√ÉO tem l√≥gica interna que fa√ßa passar
4. **Valor esperado √© hardcoded** - N√ÉO calculado internamente

**‚ùå ERRADO - Teste com l√≥gica interna:**

```cpp
It("deve calcular modificador correto para score 15", [this]()
{
    // ‚ùå ERRADO: Teste calcula o resultado internamente
    int32 Score = 15;
    int32 ExpectedModifier = (Score - 10) / 2;  // ‚ùå L√≥gica interna!

    int32 Result = CalculationHelpers::CalculateAbilityModifier(Score);

    TestEqual("Modificador deve ser correto", Result, ExpectedModifier);
    // ‚ùå Este teste passaria mesmo se CalculateAbilityModifier estivesse errado!
});
```

**‚úÖ CORRETO - Teste sem l√≥gica interna:**

```cpp
It("deve calcular modificador correto para score 15 (modificador +2)", [this]()
{
    // ‚úÖ CORRETO: Valor esperado √© hardcoded, n√£o calculado
    int32 Score = 15;
    int32 ExpectedModifier = 2;  // ‚úÖ Valor fixo conhecido

    // Act: Envia para o m√≥dulo oficial
    int32 Result = CalculationHelpers::CalculateAbilityModifier(Score);

    // Assert: Compara com valor fixo
    TestEqual("Modificador para score 15 deve ser +2", Result, ExpectedModifier);
    // ‚úÖ Este teste falha se CalculateAbilityModifier estiver errado!
});
```

**üé≠ Uso Correto de Mocks:**

**Mocks s√£o para simular dados, N√ÉO para implementar l√≥gica:**

```cpp
// ‚úÖ CORRETO: Mock simula dados conhecidos
It("deve encontrar feat row quando existe", [this]()
{
    // Arrange: Mock de DataTable com dados conhecidos
    UDataTable* MockDataTable = NewObject<UDataTable>();
    FFeatDataRow* TestRow = new FFeatDataRow();
    TestRow->FeatName = TEXT("Great Weapon Master");
    MockDataTable->AddRow(FName(TEXT("Great Weapon Master")), *TestRow);

    // Act: Envia para o m√≥dulo oficial
    FFeatDataRow* Result = DataTableHelpers::FindFeatRow(
        TEXT("Great Weapon Master"),
        MockDataTable  // ‚úÖ Mock apenas simula dados, n√£o implementa l√≥gica
    );

    // Assert: Verifica resultado com valor conhecido
    TestNotNull("Deve encontrar row", Result);
    TestEqual("FeatName deve ser Great Weapon Master",
              Result->FeatName, TEXT("Great Weapon Master"));  // ‚úÖ Valor fixo
    // ‚úÖ Teste falha se FindFeatRow estiver errado!
});
```

**‚ùå ERRADO - Mock implementa l√≥gica:**

```cpp
// ‚ùå ERRADO: Teste implementa l√≥gica de busca internamente
It("deve encontrar feat row quando existe", [this]()
{
    UDataTable* MockDataTable = NewObject<UDataTable>();
    // ... setup mock ...

    // ‚ùå ERRADO: Teste implementa l√≥gica de busca
    FFeatDataRow* ExpectedRow = nullptr;
    for (auto& Pair : MockDataTable->GetRowMap())
    {
        if (Pair.Key == TEXT("Great Weapon Master"))
        {
            ExpectedRow = (FFeatDataRow*)Pair.Value;
            break;
        }
    }

    FFeatDataRow* Result = DataTableHelpers::FindFeatRow(TEXT("Great Weapon Master"), MockDataTable);

    TestEqual("Deve ser o mesmo row", Result, ExpectedRow);
    // ‚ùå Este teste passaria mesmo se FindFeatRow estiver errado!
});
```

**Checklist obrigat√≥rio:**

- [ ] Valor esperado √© hardcoded (n√£o calculado)?
- [ ] Teste chama a fun√ß√£o real do m√≥dulo oficial?
- [ ] Mock apenas simula dados (n√£o implementa l√≥gica)?
- [ ] Teste falharia se o c√≥digo estivesse errado?
- [ ] N√£o h√° l√≥gica de c√°lculo no teste?

### 2. Green: Implementa√ß√£o M√≠nima

**ALWAYS** implementar a solu√ß√£o mais simples que faz o teste passar:

```cpp
// Implementa√ß√£o m√≠nima para passar no teste
int32 FPointBuyMotor::CalculatePointBuyCost(int32 Score)
{
    if (Score == 15) return 9;  // Implementa√ß√£o m√≠nima
    return 0;
}
```

**Por que implementa√ß√£o m√≠nima:**
- Foca em fazer o teste passar
- Evita over-engineering
- Permite evoluir incrementalmente
- Mant√©m o ciclo r√°pido

### 3. Refactor: Melhorar com Seguran√ßa

**ALWAYS** refatorar com testes verdes garantindo que nada quebra:

```cpp
// Refatora√ß√£o com testes garantindo comportamento
int32 FPointBuyMotor::CalculatePointBuyCost(int32 Score)
{
    // L√≥gica completa, mas testes garantem que funciona
    if (Score < DnDConstants::MIN_POINT_BUY_SCORE || Score > DnDConstants::MAX_POINT_BUY_SCORE)
    {
        return 0;
    }

    // Tabela de custos D&D 5e
    const TMap<int32, int32> CostTable = {
        {8, 0}, {9, 1}, {10, 2}, {11, 3}, {12, 4},
        {13, 5}, {14, 7}, {15, 9}
    };

    return CostTable.Contains(Score) ? CostTable[Score] : 0;
}
```

**Por que refatorar com testes:**
- Testes garantem que comportamento n√£o muda
- Permite refatora√ß√µes agressivas sem medo
- Detecta regress√µes imediatamente
- Mant√©m c√≥digo limpo e eficiente

## üîó Integra√ß√£o com Outras Regras

### Clean Code Mandatory

**TDD for√ßa testabilidade, que √© um princ√≠pio de Clean Code:**

- ‚úÖ Fun√ß√µes test√°veis s√£o desacopladas
- ‚úÖ Testes for√ßam Single Responsibility
- ‚úÖ TDD elimina depend√™ncias ocultas
- ‚úÖ Testes documentam comportamento esperado

**SINERGIA:** TDD + Clean Code = C√≥digo de alta qualidade

### Execution Guard

**STOP execution se c√≥digo cr√≠tico n√£o tiver testes:**

```
üõë EXECUTION STOPPED - Missing Tests

I cannot implement this critical function without tests first.
According to TDD rule, all helpers/motors/validators must have
tests written BEFORE implementation.

**Missing:**
- Test for CalculatePointBuyCost()
- Test for ValidateMulticlassRequirements()

**Correct Approach:**
1. Write tests that define expected behavior (Red)
2. Implement minimal solution (Green)
3. Refactor with tests ensuring nothing breaks (Refactor)

**Reference:**
- TDD Rule: Test-First for critical code
- Clean Code: Testability principle
```

### Testing Rules

**Complementa `testing.mdc`:**

- `testing.mdc`: **COMO** testar (estrutura, padr√µes, organiza√ß√£o)
- `test-driven-development-core.mdc`: **QUANDO** testar (antes ou depois) e **POR QU√ä**

## üìö Refer√™ncias e Documenta√ß√£o

### Conceitos Fundamentais

**Red-Green-Refactor:**
1. **Red**: Escrever teste que falha (define contrato)
2. **Green**: Implementa√ß√£o m√≠nima (faz teste passar)
3. **Refactor**: Melhorar c√≥digo (com testes garantindo)

**Testability:**
- Fun√ß√µes puras (sem side effects)
- Par√¢metros claros (sem depend√™ncias ocultas)
- Retornos verific√°veis (n√£o void sem efeitos observ√°veis)

**Automation Spec (Unreal Engine):**
- `BEGIN_DEFINE_SPEC` / `END_DEFINE_SPEC` para classes de teste
- `Describe` / `It` para especifica√ß√µes hier√°rquicas
- `BeforeEach` / `AfterEach` para setup/teardown
- Flags: `ProductFilter`, `ApplicationContextMask`

## üéì Benef√≠cios do TDD

- ‚úÖ **Documenta√ß√£o Viva**: Testes documentam comportamento esperado
- ‚úÖ **Confian√ßa em Refatora√ß√£o**: Testes garantem que nada quebra
- ‚úÖ **Detec√ß√£o Precoce de Bugs**: Testes falham imediatamente quando algo quebra
- ‚úÖ **Design Melhor**: TDD for√ßa interfaces claras e desacopladas
- ‚úÖ **Redu√ß√£o de D√≠vida T√©cnica**: C√≥digo testado √© mais f√°cil de manter
- ‚úÖ **Facilita CI/CD**: Testes automatizados permitem integra√ß√£o cont√≠nua

## üö´ O Que N√ÉO Fazer

- ‚ùå **NUNCA** implementar c√≥digo cr√≠tico sem testes
- ‚ùå **NUNCA** escrever testes depois "s√≥ para cobrir"
- ‚ùå **NUNCA** pular o ciclo Red-Green-Refactor
- ‚ùå **NUNCA** criar testes que dependem de ordem de execu√ß√£o
- ‚ùå **NUNCA** criar testes lentos ou n√£o determin√≠sticos
- ‚ùå **NUNCA** aceitar c√≥digo cr√≠tico sem testes correspondentes
- ‚ùå **NUNCA** criar testes com l√≥gica interna (calcular resultado esperado)
- ‚ùå **NUNCA** usar mocks para implementar l√≥gica (apenas para simular dados)
- ‚ùå **NUNCA** fazer teste que passa mesmo se a fun√ß√£o estiver errada

## üîÑ Fluxo de Trabalho TDD

```
1. Escrever Teste (Red)
   ‚Üì
2. Verificar que Teste Falha
   ‚Üì
3. Implementa√ß√£o M√≠nima (Green)
   ‚Üì
4. Verificar que Teste Passa
   ‚Üì
5. Refatorar (Refactor)
   ‚Üì
6. Verificar que Testes Ainda Passam
   ‚Üì
7. Pr√≥ximo Teste (voltar ao passo 1)
```

---

**This rule has HIGH priority (4) and integrates with `clean-code-mandatory.mdc` and `testing.mdc`.**
