---
description: CRITICAL RULE - Test-Driven Development (TDD) methodology. Write tests BEFORE implementation for critical code.
globs: ["*.cpp", "*.h"]
alwaysApply: true
---

# üß™ Test-Driven Development (TDD) Rule

## üéØ Objetivo

**ALWAYS** seguir o paradigma Test-Driven Development (TDD) para c√≥digo cr√≠tico e reutiliz√°vel, garantindo que testes sejam escritos **ANTES** da implementa√ß√£o, seguindo o ciclo **Red-Green-Refactor**.

## üö® REGRA PRINCIPAL - TEST-FIRST üö®

**ALWAYS** escrever testes **ANTES** da implementa√ß√£o quando:

- ‚úÖ **Criando nova fun√ß√£o helper/utility** (em `Utils/` ou `Helpers/`)
- ‚úÖ **Implementando l√≥gica de neg√≥cio** (c√°lculos, valida√ß√µes, transforma√ß√µes)
- ‚úÖ **Criando novos motores** (`*Motor.cpp` - PointBuy, Multiclass, RaceBonus)
- ‚úÖ **Criando novos validators** (`*Validator.cpp`)
- ‚úÖ **Adicionando c√°lculos complexos** (modificadores, profici√™ncias, atributos)
- ‚úÖ **Implementando regras de neg√≥cio** (regras D&D, multiclassing, point buy)
- ‚úÖ **Refatorando c√≥digo cr√≠tico** (escrever testes primeiro para garantir comportamento)

**NEVER** implementar c√≥digo cr√≠tico sem testes correspondentes.

## üîÑ O Ciclo Red-Green-Refactor

### 1. Red: Escrever Teste que Falha

**ALWAYS** come√ßar escrevendo o teste que define o comportamento esperado:

```cpp
// ‚úÖ CORRETO - Teste primeiro
BEGIN_DEFINE_SPEC(FPointBuyMotorSpec, "MyProject2.CreateSheet.PointBuy",
                  EAutomationTestFlags::ProductFilter | EAutomationTestFlags::ApplicationContextMask)
    FPointBuyMotor* Motor;
END_DEFINE_SPEC(FPointBuyMotorSpec)

void FPointBuyMotorSpec::Define()
{
    Describe("CalculatePointBuyCost", [this]()
    {
        It("deve calcular custo correto para score 15 (9 pontos)", [this]()
        {
            // Arrange
            int32 Score = 15;

            // Act
            int32 Result = FPointBuyMotor::CalculatePointBuyCost(Score);

            // Assert
            TestEqual("Custo para score 15 deve ser 9", Result, 9);
        });
    });
}
```

**Por que come√ßar pelo teste:**
- Define o contrato antes da implementa√ß√£o
- For√ßa pensar na interface primeiro
- Garante que o teste pode detectar erros
- Confirma que a infraestrutura de teste funciona

### 2. Green: Implementa√ß√£o M√≠nima

**ALWAYS** implementar a solu√ß√£o mais simples que faz o teste passar:

```cpp
// Implementa√ß√£o m√≠nima para passar no teste
int32 FPointBuyMotor::CalculatePointBuyCost(int32 Score)
{
    if (Score == 15) return 9;  // Implementa√ß√£o m√≠nima
    return 0;
}
```

**Por que implementa√ß√£o m√≠nima:**
- Foca em fazer o teste passar
- Evita over-engineering
- Permite evoluir incrementalmente
- Mant√©m o ciclo r√°pido

### 3. Refactor: Melhorar com Seguran√ßa

**ALWAYS** refatorar com testes verdes garantindo que nada quebra:

```cpp
// Refatora√ß√£o com testes garantindo comportamento
int32 FPointBuyMotor::CalculatePointBuyCost(int32 Score)
{
    // L√≥gica completa, mas testes garantem que funciona
    if (Score < DnDConstants::MIN_POINT_BUY_SCORE || Score > DnDConstants::MAX_POINT_BUY_SCORE)
    {
        return 0;
    }

    // Tabela de custos D&D 5e
    const TMap<int32, int32> CostTable = {
        {8, 0}, {9, 1}, {10, 2}, {11, 3}, {12, 4},
        {13, 5}, {14, 7}, {15, 9}
    };

    return CostTable.Contains(Score) ? CostTable[Score] : 0;
}
```

**Por que refatorar com testes:**
- Testes garantem que comportamento n√£o muda
- Permite refatora√ß√µes agressivas sem medo
- Detecta regress√µes imediatamente
- Mant√©m c√≥digo limpo e eficiente

## üìã Checklist TDD Obrigat√≥rio

**BEFORE escrever QUALQUER c√≥digo cr√≠tico, SEMPRE verificar:**

1. **[ ] Escrevi o teste que falha (Red)?**
   - Teste define comportamento esperado?
   - Teste pode detectar erros?
   - Teste compila (mesmo que fun√ß√£o n√£o exista ainda)?

2. **[ ] O teste √© at√¥mico e focado?**
   - Testa uma √∫nica coisa?
   - Nome descritivo (`<Scenario>_<Condition>_<ExpectedResult>`)?
   - Independente de outros testes?

3. **[ ] A fun√ß√£o ser√° test√°vel isoladamente?**
   - Sem depend√™ncias ocultas?
   - Par√¢metros claros?
   - Retorno verific√°vel?

4. **[ ] Implementa√ß√£o m√≠nima faz teste passar (Green)?**
   - Solu√ß√£o mais simples poss√≠vel?
   - Teste fica verde?
   - Comportamento b√°sico funciona?

5. **[ ] Refatorei com seguran√ßa (Refactor)?**
   - Testes ainda passam?
   - C√≥digo melhorado sem quebrar comportamento?
   - Clean Code aplicado?

**Se QUALQUER resposta for N√ÉO ‚Üí PARAR e corrigir antes de continuar**

## ‚ö†Ô∏è Exce√ß√µes: Quando Test-After √© Aceit√°vel

**Test-After (escrever teste depois) √© aceit√°vel quando:**

- ‚ùå **Getters/Setters simples** (sem l√≥gica)
  ```cpp
  // N√£o precisa de teste primeiro
  float GetHealth() const { return Health; }
  void SetHealth(float NewHealth) { Health = NewHealth; }
  ```

- ‚ùå **Wrappers diretos de API Unreal** (sem l√≥gica customizada)
  ```cpp
  // Wrapper simples, testar depois se necess√°rio
  UDataTable* GetRaceDataTable() const { return RaceDataTable; }
  ```

- ‚ùå **Integra√ß√£o com Blueprint** (testar depois pode ser mais pr√°tico)
  ```cpp
  // Integra√ß√£o complexa, testar depois
  UFUNCTION(BlueprintCallable)
  void InitializeFromBlueprint(UCharacterSheetDataAsset* Asset);
  ```

- ‚ùå **Mudan√ßas muito pequenas** (< 5 linhas, sem l√≥gica complexa)
  ```cpp
  // Ajuste simples, n√£o precisa de teste primeiro
  void LogMessage(const FString& Message) { UE_LOG(LogTemp, Warning, TEXT("%s"), *Message); }
  ```

- ‚ùå **Corre√ß√µes de bugs** (escrever teste que reproduz bug, depois corrigir)
  ```cpp
  // Bug fix: escrever teste que reproduz, depois corrigir
  It("deve corrigir bug X", [this]() { /* reproduz bug */ });
  ```

**IMPORTANTE:** Mesmo em exce√ß√µes, **SEMPRE** escrever testes quando c√≥digo for cr√≠tico ou reutiliz√°vel.

## üéØ Quando Aplicar TDD Rigorosamente

### 1. Helpers e Utils (SEMPRE TDD)

**ALWAYS** test-first para fun√ß√µes em `Utils/` ou `Helpers/`:

```cpp
// ‚úÖ CORRETO - Teste primeiro
// 1. Red: Escrever teste
It("deve calcular modificador correto para score 10 (modificador 0)", [this]()
{
    int32 Result = CalculationHelpers::CalculateAbilityModifier(10);
    TestEqual("Modificador para score 10 deve ser 0", Result, 0);
});

// 2. Green: Implementa√ß√£o m√≠nima
int32 CalculationHelpers::CalculateAbilityModifier(int32 Score)
{
    return (Score - 10) / 2;  // F√≥rmula D&D
}

// 3. Refactor: Melhorar (com testes garantindo)
```

### 2. Motores (SEMPRE TDD)

**ALWAYS** test-first para l√≥gica de motores:

```cpp
// ‚úÖ CORRETO - Teste primeiro para motor
Describe("PointBuyMotor", [this]()
{
    It("deve validar aloca√ß√£o que gasta exatamente 27 pontos", [this]()
    {
        // Teste define comportamento esperado
        TMap<FName, int32> BaseScores;
        // ... setup ...
        bool Result = FPointBuyMotor::ValidateAllocation(BaseScores, 27);
        TestTrue("Aloca√ß√£o v√°lida deve ser aceita", Result);
    });
});
```

### 3. Validators (SEMPRE TDD)

**ALWAYS** test-first para regras de valida√ß√£o:

```cpp
// ‚úÖ CORRETO - Teste primeiro para validator
Describe("ValidateAbilityScoreRange", [this]()
{
    It("deve validar score dentro do range padr√£o (1-30)", [this]()
    {
        bool Result = ValidationHelpers::ValidateAbilityScoreRange(15);
        TestTrue("Score 15 deve ser v√°lido", Result);
    });

    It("deve rejeitar score fora do range (0 ou negativo)", [this]()
    {
        bool Result = ValidationHelpers::ValidateAbilityScoreRange(0);
        TestFalse("Score 0 deve ser inv√°lido", Result);
    });
});
```

## üîó Integra√ß√£o com Outras Regras

### Clean Code Mandatory

**TDD for√ßa testabilidade, que √© um princ√≠pio de Clean Code:**

- ‚úÖ Fun√ß√µes test√°veis s√£o desacopladas
- ‚úÖ Testes for√ßam Single Responsibility
- ‚úÖ TDD elimina depend√™ncias ocultas
- ‚úÖ Testes documentam comportamento esperado

**SINERGIA:** TDD + Clean Code = C√≥digo de alta qualidade

### Execution Guard

**STOP execution se c√≥digo cr√≠tico n√£o tiver testes:**

```
üõë EXECUTION STOPPED - Missing Tests

I cannot implement this critical function without tests first.
According to TDD rule, all helpers/motors/validators must have
tests written BEFORE implementation.

**Missing:**
- Test for CalculatePointBuyCost()
- Test for ValidateMulticlassRequirements()

**Correct Approach:**
1. Write tests that define expected behavior (Red)
2. Implement minimal solution (Green)
3. Refactor with tests ensuring nothing breaks (Refactor)

**Reference:**
- TDD Rule: Test-First for critical code
- Clean Code: Testability principle
```

### Testing Rules

**Complementa `testing.mdc`:**

- `testing.mdc`: **COMO** testar (estrutura, padr√µes, organiza√ß√£o)
- `test-driven-development.mdc`: **QUANDO** testar (antes ou depois) e **POR QU√ä**

## üìö Refer√™ncias e Documenta√ß√£o

### Documenta√ß√£o do Projeto

- `memorias/TDD.md` - Relat√≥rio completo sobre TDD na Unreal Engine
- `docs/technical/guides/testing.md` - Guia de testes do projeto
- `docs/technical/guides/testing-implementation-plan.md` - Plano de implementa√ß√£o

### Conceitos Fundamentais

**Red-Green-Refactor:**
1. **Red**: Escrever teste que falha (define contrato)
2. **Green**: Implementa√ß√£o m√≠nima (faz teste passar)
3. **Refactor**: Melhorar c√≥digo (com testes garantindo)

**Testability:**
- Fun√ß√µes puras (sem side effects)
- Par√¢metros claros (sem depend√™ncias ocultas)
- Retornos verific√°veis (n√£o void sem efeitos observ√°veis)

**Automation Spec (Unreal Engine):**
- `BEGIN_DEFINE_SPEC` / `END_DEFINE_SPEC` para classes de teste
- `Describe` / `It` para especifica√ß√µes hier√°rquicas
- `BeforeEach` / `AfterEach` para setup/teardown
- Flags: `ProductFilter`, `ApplicationContextMask`

## ‚úÖ Checklist Final

Antes de considerar c√≥digo "pronto" com TDD:

- [ ] Teste foi escrito ANTES da implementa√ß√£o (Red)?
- [ ] Teste define comportamento esperado claramente?
- [ ] Implementa√ß√£o m√≠nima faz teste passar (Green)?
- [ ] C√≥digo foi refatorado com testes garantindo (Refactor)?
- [ ] Testes cobrem casos v√°lidos, inv√°lidos e edge cases?
- [ ] Testes s√£o independentes e r√°pidos (< 1 segundo cada)?
- [ ] Nomes de testes s√£o descritivos (`<Scenario>_<Condition>_<ExpectedResult>`)?
- [ ] Testes servem como documenta√ß√£o viva do comportamento?

## üéì Benef√≠cios do TDD

- ‚úÖ **Documenta√ß√£o Viva**: Testes documentam comportamento esperado
- ‚úÖ **Confian√ßa em Refatora√ß√£o**: Testes garantem que nada quebra
- ‚úÖ **Detec√ß√£o Precoce de Bugs**: Testes falham imediatamente quando algo quebra
- ‚úÖ **Design Melhor**: TDD for√ßa interfaces claras e desacopladas
- ‚úÖ **Redu√ß√£o de D√≠vida T√©cnica**: C√≥digo testado √© mais f√°cil de manter
- ‚úÖ **Facilita CI/CD**: Testes automatizados permitem integra√ß√£o cont√≠nua

## üö´ O Que N√ÉO Fazer

- ‚ùå **NUNCA** implementar c√≥digo cr√≠tico sem testes
- ‚ùå **NUNCA** escrever testes depois "s√≥ para cobrir"
- ‚ùå **NUNCA** pular o ciclo Red-Green-Refactor
- ‚ùå **NUNCA** criar testes que dependem de ordem de execu√ß√£o
- ‚ùå **NUNCA** criar testes lentos ou n√£o determin√≠sticos
- ‚ùå **NUNCA** aceitar c√≥digo cr√≠tico sem testes correspondentes

## üîÑ Fluxo de Trabalho TDD

```
1. Escrever Teste (Red)
   ‚Üì
2. Verificar que Teste Falha
   ‚Üì
3. Implementa√ß√£o M√≠nima (Green)
   ‚Üì
4. Verificar que Teste Passa
   ‚Üì
5. Refatorar (Refactor)
   ‚Üì
6. Verificar que Testes Ainda Passam
   ‚Üì
7. Pr√≥ximo Teste (voltar ao passo 1)
```

## üìù Exemplo Completo: TDD de Helper

### Passo 1: Red (Teste que Falha)

```cpp
// CalculationHelpersTests.cpp
Describe("CalculateProficiencyBonus", [this]()
{
    It("deve calcular b√¥nus correto para n√≠vel 1 (b√¥nus +2)", [this]()
    {
        // Arrange
        int32 Level = 1;

        // Act
        int32 Result = CalculationHelpers::CalculateProficiencyBonus(Level);

        // Assert
        TestEqual("B√¥nus de profici√™ncia para n√≠vel 1 deve ser +2", Result, 2);
    });
});
```

### Passo 2: Green (Implementa√ß√£o M√≠nima)

```cpp
// CalculationHelpers.cpp
int32 CalculationHelpers::CalculateProficiencyBonus(int32 Level)
{
    if (Level == 1) return 2;  // Implementa√ß√£o m√≠nima
    return 0;
}
```

### Passo 3: Refactor (Melhorar com Seguran√ßa)

```cpp
// CalculationHelpers.cpp
int32 CalculationHelpers::CalculateProficiencyBonus(int32 Level)
{
    // F√≥rmula D&D 5e: +2 a cada 4 n√≠veis (arredondado para cima)
    // N√≠vel 1-4: +2, 5-8: +3, 9-12: +4, etc.
    return 2 + ((Level - 1) / 4);
}
```

**Testes garantem que comportamento n√£o muda durante refatora√ß√£o!**

---

## üéØ Resumo Executivo

**TDD √© OBRIGAT√ìRIO para:**
- ‚úÖ Helpers/Utils
- ‚úÖ Motores
- ‚úÖ Validators
- ‚úÖ L√≥gica de neg√≥cio cr√≠tica

**TDD √© OPCIONAL para:**
- ‚ùå Getters/Setters simples
- ‚ùå Wrappers de API
- ‚ùå Integra√ß√£o Blueprint
- ‚ùå Mudan√ßas muito pequenas

**Ciclo sempre: Red ‚Üí Green ‚Üí Refactor**

**Benef√≠cio principal:** C√≥digo test√°vel, desacoplado e confi√°vel.

---

**This rule has HIGH priority and integrates with `clean-code-mandatory.mdc` and `testing.mdc`.**
