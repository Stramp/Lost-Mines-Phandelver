---
description: Rules to keep code clean, organized and of quality
alwaysApply: true
---

# Code Quality and Organization

## General Principles
- **ALWAYS** write clean and readable code
- **ALWAYS** follow Unreal Engine standards
- **ALWAYS** document complex code
- **ALWAYS** keep functions small and focused
- **ALWAYS** use descriptive names

## Code Organization

### File Structure
- One .h and .cpp file per class
- File name = class name
- Organize in subdirectories by functionality:
  - `Characters/` - Characters
  - `Components/` - Components
  - `UI/` - User interface
  - `Gameplay/` - Game mechanics
  - `Utils/` - Utilities

### Organization within Files
1. **Header (.h):**
   - Copyright
   - #pragma once
   - Includes
   - Forward declarations
   - UCLASS/USTRUCT/UENUM
   - Class with:
     - Public: constructor, public functions, public UPROPERTY/UFUNCTION
     - Protected: protected functions, protected UPROPERTY/UFUNCTION
     - Private: private members

2. **Implementation (.cpp):**
   - Copyright
   - Include corresponding header
   - Project includes
   - Engine includes
   - STL includes (if necessary)
   - Implementations

## Consistent Naming

### Classes
- Actors: `A` prefix (ex: `AMyCharacter`)
- UObjects: `U` prefix (ex: `UMyComponent`)
- Structs: `F` prefix (ex: `FPlayerStats`)
- Enums: `E` prefix (ex: `EPlayerState`)
- Interfaces: `I` prefix (ex: `IInteractable`)

### Variables
- Booleans: `b` prefix (ex: `bIsRunning`)
- Floats/Ints: PascalCase (ex: `Health`, `MaxHealth`)
- Constants: `const` + PascalCase (ex: `const float MaxSpeed = 1000.0f`)

### Functions
- PascalCase (ex: `BeginPlay()`, `TakeDamage()`)
- Verbs for actions (ex: `CalculateDamage()`, `SpawnEnemy()`)
- Get/Set for properties (ex: `GetHealth()`, `SetHealth()`)

## Comments and Documentation

### When to Comment
- **ALWAYS** document public functions
- **ALWAYS** explain "why" not "what"
- **ALWAYS** document complex or non-obvious code
- **NEVER** comment obvious code

### Comment Format
```cpp
/**
 * Calculates damage based on weapon type and target defense.
 *
 * @param WeaponType Attacking weapon type
 * @param TargetDefense Target defense value
 * @return Calculated damage (always >= 0)
 */
float CalculateDamage(EWeaponType WeaponType, float TargetDefense);
```

## Refactoring and Cleanup

### When to Refactor
- Functions with more than 50 lines
- Duplicated code (DRY - Don't Repeat Yourself)
- Confusing or non-descriptive names
- High cyclomatic complexity
- Too many parameters (> 4)

### Best Practices
- **ALWAYS** remove commented code (use Git for history)
- **ALWAYS** remove unused includes
- **ALWAYS** remove unused variables
- **ALWAYS** use const when appropriate
- **ALWAYS** prefer const references over copies

## Validation and Errors

### Error Handling
- Use `check()` for critical assertions (debug)
- Use `ensure()` for important checks
- Use `UE_LOG()` for appropriate logging
- Return boolean values or error codes when appropriate

### Input Validation
- **ALWAYS** validate public function parameters
- **ALWAYS** validate network data (RPCs)
- **ALWAYS** validate Blueprint data

## Performance

### Optimizations
- Disable `Tick` if not using
- Use object pooling for frequent objects
- Prefer `TArray::Reserve()` when size is known
- Use `FName` for frequent comparisons
- Cache results of expensive calculations

### When NOT to Optimize
- Don't optimize prematurely
- Profile before optimizing
- Readability > Performance (except hot paths)

## Testing and Validation

### Before Committing
- **ALWAYS** verify it compiles
- **ALWAYS** test basic functionalities
- **ALWAYS** verify it doesn't break existing Blueprints
- **ALWAYS** remove temporary debug logs

## Clean Code Checklist

Before considering code "ready":
- [ ] Compiles without errors or warnings
- [ ] Follows naming standards
- [ ] Is organized and readable
- [ ] Functions are small and focused
- [ ] Complex code is documented
- [ ] No duplicated code
- [ ] No commented code
- [ ] Unused includes removed
- [ ] Const used when appropriate
- [ ] Adequate error handling
