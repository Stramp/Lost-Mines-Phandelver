---
description: CRITICAL RULE - Test-Driven Development (TDD) practices. When to apply TDD, examples, checklists, and exceptions.
globs: ["*.cpp", "*.h"]
alwaysApply: true
priority: 4
---

# üß™ Test-Driven Development (TDD) - Practices

## üìã Checklist TDD Obrigat√≥rio

**BEFORE escrever QUALQUER c√≥digo cr√≠tico, SEMPRE verificar:**

1. **[ ] Escrevi o teste que falha (Red)?**
   - Teste define comportamento esperado?
   - Teste pode detectar erros?
   - Teste compila (mesmo que fun√ß√£o n√£o exista ainda)?

2. **[ ] O teste √© at√¥mico e focado?**
   - Testa uma √∫nica coisa?
   - Nome descritivo (`<Scenario>_<Condition>_<ExpectedResult>`)?
   - Independente de outros testes?

3. **[ ] O teste N√ÉO tem l√≥gica interna?**
   - Valor esperado √© hardcoded (n√£o calculado)?
   - Teste chama a fun√ß√£o real do m√≥dulo oficial?
   - Mock apenas simula dados (n√£o implementa l√≥gica)?
   - Teste falharia se o c√≥digo estivesse errado?
   - N√£o h√° l√≥gica de c√°lculo no teste?

4. **[ ] A fun√ß√£o ser√° test√°vel isoladamente?**
   - Sem depend√™ncias ocultas?
   - Par√¢metros claros?
   - Retorno verific√°vel?

5. **[ ] Implementa√ß√£o m√≠nima faz teste passar (Green)?**
   - Solu√ß√£o mais simples poss√≠vel?
   - Teste fica verde?
   - Comportamento b√°sico funciona?

6. **[ ] Refatorei com seguran√ßa (Refactor)?**
   - Testes ainda passam?
   - C√≥digo melhorado sem quebrar comportamento?
   - Clean Code aplicado?

**Se QUALQUER resposta for N√ÉO ‚Üí PARAR e corrigir antes de continuar**

## ‚ö†Ô∏è Exce√ß√µes: Quando Test-After √© Aceit√°vel

**Test-After (escrever teste depois) √© aceit√°vel quando:**

- ‚ùå **Getters/Setters simples** (sem l√≥gica)
  ```cpp
  // N√£o precisa de teste primeiro
  float GetHealth() const { return Health; }
  void SetHealth(float NewHealth) { Health = NewHealth; }
  ```

- ‚ùå **Wrappers diretos de API Unreal** (sem l√≥gica customizada)
  ```cpp
  // Wrapper simples, testar depois se necess√°rio
  UDataTable* GetRaceDataTable() const { return RaceDataTable; }
  ```

- ‚ùå **Integra√ß√£o com Blueprint** (testar depois pode ser mais pr√°tico)
  ```cpp
  // Integra√ß√£o complexa, testar depois
  UFUNCTION(BlueprintCallable)
  void InitializeFromBlueprint(UCharacterSheetDataAsset* Asset);
  ```

- ‚ùå **Mudan√ßas muito pequenas** (< 5 linhas, sem l√≥gica complexa)
  ```cpp
  // Ajuste simples, n√£o precisa de teste primeiro
  void LogMessage(const FString& Message) { UE_LOG(LogTemp, Warning, TEXT("%s"), *Message); }
  ```

- ‚ùå **Corre√ß√µes de bugs** (escrever teste que reproduz bug, depois corrigir)
  ```cpp
  // Bug fix: escrever teste que reproduz, depois corrigir
  It("deve corrigir bug X", [this]() { /* reproduz bug */ });
  ```

**IMPORTANTE:** Mesmo em exce√ß√µes, **SEMPRE** escrever testes quando c√≥digo for cr√≠tico ou reutiliz√°vel.

## üéØ Quando Aplicar TDD Rigorosamente

### 1. Helpers e Utils (SEMPRE TDD)

**ALWAYS** test-first para fun√ß√µes em `Utils/` ou `Helpers/`:

```cpp
// ‚úÖ CORRETO - Teste primeiro
// 1. Red: Escrever teste
It("deve calcular modificador correto para score 10 (modificador 0)", [this]()
{
    int32 Result = CalculationHelpers::CalculateAbilityModifier(10);
    TestEqual("Modificador para score 10 deve ser 0", Result, 0);
});

// 2. Green: Implementa√ß√£o m√≠nima
int32 CalculationHelpers::CalculateAbilityModifier(int32 Score)
{
    return (Score - 10) / 2;  // F√≥rmula D&D
}

// 3. Refactor: Melhorar (com testes garantindo)
```

### 2. Motores (SEMPRE TDD)

**ALWAYS** test-first para l√≥gica de motores:

```cpp
// ‚úÖ CORRETO - Teste primeiro para motor
Describe("PointBuyMotor", [this]()
{
    It("deve validar aloca√ß√£o que gasta exatamente 27 pontos", [this]()
    {
        // Teste define comportamento esperado
        TMap<FName, int32> BaseScores;
        // ... setup ...
        bool Result = FPointBuyMotor::ValidateAllocation(BaseScores, 27);
        TestTrue("Aloca√ß√£o v√°lida deve ser aceita", Result);
    });
});
```

### 3. Validators (SEMPRE TDD)

**ALWAYS** test-first para regras de valida√ß√£o:

```cpp
// ‚úÖ CORRETO - Teste primeiro para validator
Describe("ValidateAbilityScoreRange", [this]()
{
    It("deve validar score dentro do range padr√£o (1-30)", [this]()
    {
        bool Result = ValidationHelpers::ValidateAbilityScoreRange(15);
        TestTrue("Score 15 deve ser v√°lido", Result);
    });

    It("deve rejeitar score fora do range (0 ou negativo)", [this]()
    {
        bool Result = ValidationHelpers::ValidateAbilityScoreRange(0);
        TestFalse("Score 0 deve ser inv√°lido", Result);
    });
});
```

## üìù Exemplo Completo: TDD de Helper

### Passo 1: Red (Teste que Falha)

```cpp
// CalculationHelpersTests.cpp
Describe("CalculateProficiencyBonus", [this]()
{
    It("deve calcular b√¥nus correto para n√≠vel 1 (b√¥nus +2)", [this]()
    {
        // Arrange
        int32 Level = 1;

        // Act
        int32 Result = CalculationHelpers::CalculateProficiencyBonus(Level);

        // Assert
        TestEqual("B√¥nus de profici√™ncia para n√≠vel 1 deve ser +2", Result, 2);
    });
});
```

### Passo 2: Green (Implementa√ß√£o M√≠nima)

```cpp
// CalculationHelpers.cpp
int32 CalculationHelpers::CalculateProficiencyBonus(int32 Level)
{
    if (Level == 1) return 2;  // Implementa√ß√£o m√≠nima
    return 0;
}
```

### Passo 3: Refactor (Melhorar com Seguran√ßa)

```cpp
// CalculationHelpers.cpp
int32 CalculationHelpers::CalculateProficiencyBonus(int32 Level)
{
    // F√≥rmula D&D 5e: +2 a cada 4 n√≠veis (arredondado para cima)
    // N√≠vel 1-4: +2, 5-8: +3, 9-12: +4, etc.
    return 2 + ((Level - 1) / 4);
}
```

**Testes garantem que comportamento n√£o muda durante refatora√ß√£o!**

## ‚úÖ Checklist Final

Antes de considerar c√≥digo "pronto" com TDD:

- [ ] Teste foi escrito ANTES da implementa√ß√£o (Red)?
- [ ] Teste define comportamento esperado claramente?
- [ ] **Teste N√ÉO tem l√≥gica interna (valor esperado √© hardcoded)?**
- [ ] **Teste chama a fun√ß√£o real do m√≥dulo oficial?**
- [ ] **Mock apenas simula dados (n√£o implementa l√≥gica)?**
- [ ] **Teste falharia se o c√≥digo estivesse errado?**
- [ ] Implementa√ß√£o m√≠nima faz teste passar (Green)?
- [ ] C√≥digo foi refatorado com testes garantindo (Refactor)?
- [ ] Testes cobrem casos v√°lidos, inv√°lidos e edge cases?
- [ ] Testes s√£o independentes e r√°pidos (< 1 segundo cada)?
- [ ] Nomes de testes s√£o descritivos (`<Scenario>_<Condition>_<ExpectedResult>`)?
- [ ] Testes servem como documenta√ß√£o viva do comportamento?

## üìö Refer√™ncias e Documenta√ß√£o

### Documenta√ß√£o do Projeto

- **[TDD Complete Guide](../../docs/technical/guides/tdd-complete-guide.md)** - Guia completo consolidado de TDD
  - Ciclo Red-Green-Refactor detalhado
  - Princ√≠pios fundamentais
  - Quando aplicar TDD vs Test-After
  - TDD na Unreal Engine 5.7
  - Erros comuns e anti-padr√µes
  - Benef√≠cios e boas pr√°ticas
  - Recursos de aprendizado
- `memorias/TDD.md` - Relat√≥rio completo sobre TDD na Unreal Engine
- `docs/technical/guides/testing.md` - Guia de testes do projeto
- `docs/technical/guides/testing-implementation-plan.md` - Plano de implementa√ß√£o

## üéØ Resumo Executivo

**TDD √© OBRIGAT√ìRIO para:**
- ‚úÖ Helpers/Utils
- ‚úÖ Motores
- ‚úÖ Validators
- ‚úÖ L√≥gica de neg√≥cio cr√≠tica

**TDD √© OPCIONAL para:**
- ‚ùå Getters/Setters simples
- ‚ùå Wrappers de API
- ‚ùå Integra√ß√£o Blueprint
- ‚ùå Mudan√ßas muito pequenas

**Ciclo sempre: Red ‚Üí Green ‚Üí Refactor**

**Benef√≠cio principal:** C√≥digo test√°vel, desacoplado e confi√°vel.

---

**This rule has HIGH priority (4) and integrates with `test-driven-development-core.mdc`, `clean-code-mandatory.mdc` and `testing.mdc`.**
