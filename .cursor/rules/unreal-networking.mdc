---
description: Networking and multiplayer in Unreal Engine
globs: ["*.cpp", "*.h"]
alwaysApply: false
---

# Networking - Unreal Engine 5.7

## Property Replication
- Use `UPROPERTY(Replicated)` for properties that need to synchronize
- Use `ReplicatedUsing = FunctionName` for callback when value changes
- Implement `GetLifetimeReplicatedProps()` to configure replication

## Replication Example
```cpp
// Header
UPROPERTY(Replicated, ReplicatedUsing = OnRep_Health)
float Health;

UFUNCTION()
void OnRep_Health();

// Cpp
void AMyActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);
    DOREPLIFETIME(AMyActor, Health);
}

void AMyActor::OnRep_Health()
{
    // Called when Health is replicated
}
```

## RPCs (Remote Procedure Calls)
- **Server RPC** - Client calls server
  ```cpp
  UFUNCTION(Server, Reliable)
  void ServerFireWeapon();
  ```
- **Client RPC** - Server calls client
  ```cpp
  UFUNCTION(Client, Reliable)
  void ClientShowDamage(float DamageAmount);
  ```
- **NetMulticast** - Server calls all clients
  ```cpp
  UFUNCTION(NetMulticast, Reliable)
  void MulticastExplode();
  ```

## RPC Validation
- Use `WithValidation` to validate RPCs:
  ```cpp
  UFUNCTION(Server, Reliable, WithValidation)
  void ServerFireWeapon();

  bool ServerFireWeapon_Validate() { return true; }
  void ServerFireWeapon_Implementation() { /* code */ }
  ```

## Best Practices
- Minimize replicated data (only what is necessary)
- Use `ReplicatedUsing` to update UI/local when values change
- Reliable RPCs are guaranteed, unreliable ones can be lost
- Use `NetPriority` to control replication order
- Consider `NetUpdateFrequency` to control update frequency
- **ALWAYS** validate server RPCs to prevent cheating
