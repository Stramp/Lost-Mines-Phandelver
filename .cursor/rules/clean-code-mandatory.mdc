---
description: CRITICAL RULE - Clean Code and Design Patterns are MANDATORY in ALL situations
globs: ["*.cpp", "*.h", "*.hpp", "*.cs"]
alwaysApply: true
priority: 1
---

# âš ï¸ CRITICAL RULE - CLEAN CODE AND DESIGN PATTERNS MANDATORY âš ï¸

## ğŸš¨ RULE ZERO - MANDATORY PRE-CODE VALIDATION ğŸš¨

**BEFORE writing ANY function, ALWAYS verify:**

1. **Can this function be reused?** â†’ Goes to `Utils/` or `Helpers/`
2. **Is this function pure (no side effects)?** â†’ Can be helper
3. **Is this function in the right place?** â†’ Motor only has motor logic, no helpers
4. **Does this function follow Single Responsibility?** â†’ One function = one responsibility
5. **Is this function testable in isolation?** â†’ If not, refactor

**ğŸš¨ CRITICAL LOCATION RULE:**

- **MOTOR DOES NOT HAVE HELPERS** - Motors (`*Motor.cpp`) only contain motor logic
- **VALIDATOR DOES NOT HAVE HELPERS** - Validators only validate
- **UPDATER DOES NOT HAVE HELPERS** - Updaters only update
- **HELPERS DO NOT HAVE MOTOR LOGIC** - Helpers are pure and reusable functions

**If the function can be a helper â†’ CREATE IN Helpers/, NOT in current file**

## ğŸš¨ ABSOLUTE RULE - NO EXCEPTIONS ğŸš¨

**ALWAYS, ALWAYS, ALWAYS** apply Clean Code and C++ Design Patterns in **ALL** situations:

- âœ… Production code
- âœ… Quick tests
- âœ… Prototypes
- âœ… Bug fixes
- âœ… Refactoring
- âœ… New features
- âœ… Any line of code written

**NEVER, NEVER, NEVER** create code that violates Clean Code or Design Patterns, even if it's:

- âŒ "Just a quick test"
- âŒ "I'll fix it later"
- âŒ "It's temporary"
- âŒ "It works like this"

## MANDATORY Principles

### 1. Helper/Utility Functions

**CRITICAL RULE:** Any function that can be reused MUST be in a separate helpers/utilities file.

**ğŸš¨ ABSOLUTE LOCATION RULE:**

- âŒ **NEVER** create helper inside `*Motor.cpp` (ex: `MulticlassMotor.cpp`, `PointBuyMotor.cpp`)
- âŒ **NEVER** create helper inside `*Validator.cpp` (ex: `PointBuyValidator.cpp`)
- âŒ **NEVER** create helper inside `*Updater.cpp`
- âœ… **ALWAYS** create helper in corresponding `*Helpers.h/cpp` (ex: `MulticlassHelpers.h`)

**ALWAYS:**

- âœ… Helper functions in `Utils/` or `Helpers/`
- âœ… Parameterized functions (without internal state dependency)
- âœ… Pure functions when possible
- âœ… Functions testable in isolation
- âœ… Static functions in helper classes/namespaces

**NEVER:**

- âŒ Helper functions inside Motor/Validator/Updater files
- âŒ Helper functions inside classes when they can be reused
- âŒ Functions coupled to internal state when they can be parameterized
- âŒ Duplication of search/verification code
- âŒ "Local helper" functions that could be reused

**CRITICAL RULE - Namespace Helpers:**

**ALWAYS** verify if a helper function in an anonymous `namespace` can be separated:

- âœ… **If helper can be reused or tested separately** â†’ Move to `Helpers/` or `Utils/` file
- âœ… **If helper is pure/parameterized** â†’ MUST be in separate file
- âœ… **If helper is only used by one function** â†’ Still move to `Helpers/` if it can be tested/validated separately

**NEVER:**

- âŒ Create anonymous `namespace` helpers in core/motor files when they can be separated
- âŒ Keep helpers in core files "just because they're only used once"
- âŒ Mix helper logic with orchestration/flow logic in the same file

**CORRECT Example:**

```cpp
// MulticlassHelpers.h
class FMulticlassHelpers {
public:
    static FMulticlassProficienciesEntry ConvertProficienciesEntry(const FProficienciesEntry &SourceEntry);
};

// MulticlassMotor.cpp (core - only orchestration)
bool FMulticlassMotor::LoadClassProficiencies(...)
{
    // ... validation ...
    FMulticlassProficienciesEntry ConvertedEntry = FMulticlassHelpers::ConvertProficienciesEntry(SourceEntry);
    // ... orchestration ...
}
```

**WRONG Example:**

```cpp
// âŒ NEVER do this - helper in core file
namespace {
    FMulticlassProficienciesEntry ConvertProficienciesEntry(...) { ... }
}

bool FMulticlassMotor::LoadClassProficiencies(...)
{
    // Uses helper from anonymous namespace
}
```

**CORRECT Example:**

```cpp
// Utils/ComponentHelpers.h
UCharacterDataComponent* FindCharacterDataComponent(AActor* Owner);

// Utils/ComponentHelpers.cpp
UCharacterDataComponent* FindCharacterDataComponent(AActor* Owner)
{
    if (!Owner) return nullptr;
    return Owner->FindComponentByClass<UCharacterDataComponent>();
}
```

**WRONG Example:**

```cpp
// âŒ NEVER do this - private function coupled
private:
    UCharacterDataComponent* FindOrGetCharacterDataComponent()
    {
        if (!CharacterDataComponent)
        {
            CharacterDataComponent = GetOwner()->FindComponentByClass<UCharacterDataComponent>();
        }
        return CharacterDataComponent;
    }
```

### 2. DRY (Don't Repeat Yourself)

**CRITICAL RULE:** If you're going to use the same logic in more than one place, create a helper function.

**ALWAYS:**

- âœ… Identify duplicated code
- âœ… Extract to helper function
- âœ… Parameterize appropriately

**NEVER:**

- âŒ Copy and paste code
- âŒ "Just this once I'll duplicate"

### 3. Single Responsibility Principle (SRP)

**CRITICAL RULE:** Each function/class must have a single responsibility.

**ALWAYS:**

- âœ… Small, focused functions
- âœ… One function = one action
- âœ… Classes with single responsibility

**NEVER:**

- âŒ Functions that do multiple things
- âŒ Classes that do everything

### 4. Separation of Concerns

**CRITICAL RULE:** Separate business logic from auxiliary logic.

**ALWAYS:**

- âœ… Helpers in separate files
- âœ… Utilities in `Utils/`
- âœ… Pure functions when possible

**NEVER:**

- âŒ Mix helpers with business logic
- âŒ Couple utility functions to specific classes

### 5. Testability

**CRITICAL RULE:** Code must be testable.

**ALWAYS:**

- âœ… Parameterized functions
- âœ… No hidden dependencies
- âœ… Pure functions when possible

**NEVER:**

- âŒ Functions coupled to global state
- âŒ Hardcoded dependencies

## MANDATORY Checklist

**BEFORE writing ANY code, ALWAYS ask (in this order):**

1. **[ ] Can this function be reused?** â†’ If YES, goes to `Utils/` or `Helpers/`
2. **[ ] Is this function pure (no side effects)?** â†’ If YES, can be helper
3. **[ ] Is this function in the correct file?**
   - Motor? â†’ Only motor logic, NO helpers
   - Validator? â†’ Only validation, NO helpers
   - Updater? â†’ Only update, NO helpers
   - Helper? â†’ Only pure functions, NO motor logic
4. **[ ] Does this function depend on internal state?** â†’ Can it be parameterized?
5. **[ ] Am I duplicating code?** â†’ Extract to helper
6. **[ ] Does this function have single responsibility?** â†’ One function = one action
7. **[ ] Is this function testable in isolation?** â†’ If not, refactor
8. **[ ] Am I following Clean Code?** â†’ Verify all principles
9. **[ ] Am I following appropriate Design Patterns?** â†’ Verify patterns

**If ANY answer indicates it should be a helper â†’ STOP and create in Helpers/**

## Helpers/Utils Structure

**ALWAYS** organize helpers in:

```text
Source/MyProject2/
â”œâ”€â”€ Utils/
â”‚   â”œâ”€â”€ ComponentHelpers.h
â”‚   â”œâ”€â”€ ComponentHelpers.cpp
â”‚   â”œâ”€â”€ MathHelpers.h
â”‚   â”œâ”€â”€ MathHelpers.cpp
â”‚   â””â”€â”€ ...
```

## When to Create Helper

**ALWAYS** create helper when:

1. âœ… Function can be used in more than one place
2. âœ… Function is pure (no side effects)
3. âœ… Function does generic search/verification
4. âœ… Function does calculation/transformation
5. âœ… Function can be tested in isolation

## Exceptions

**THERE ARE NO EXCEPTIONS.** This rule is absolute.

## Final Reminder

**EVERY** line of code must follow Clean Code and Design Patterns.

**NEVER** create "temporary" or "just for testing" code that violates these rules.

**ALWAYS** think about reusability, testability, and maintainability.

---

## ğŸ“š Documentation References

**Always consult these references when applying Clean Code and Design Patterns:**

### Clean Code
- **Fundamental principles**: Small functions, descriptive names, single responsibility
- **DRY (Don't Repeat Yourself)**: Eliminate code duplication
- **Separation of Concerns**: Separate business logic from auxiliary logic
- **Testability**: Code must be testable in isolation

### C++ Design Patterns
- **Strategy Pattern**: For interchangeable algorithms
- **Factory Pattern**: For object creation
- **Observer Pattern**: For events and notifications
- **RAII (Resource Acquisition Is Initialization)**: Automatic resource management
- **Guard Pattern**: To ensure resource cleanup (ex: `FValidationGuard`)

### Unreal Engine 5.7
- **UPROPERTY/UFUNCTION**: Macros to expose properties and functions to Blueprint
- **USTRUCT**: For data structures
- **Component-Based Architecture**: Separate functionalities into components
- **Data-Driven Design**: Use Data Tables and Data Assets instead of hardcode
- **Replication**: Prepare code for multiplayer from the start

### Related Rules
- `.cursor/rules/clean-code-mandatory.mdc` - This rule (maximum priority)
- `.cursor/rules/test-driven-development-core.mdc` - TDD mandatory for critical code
- `.cursor/rules/execution-guard.mdc` - Project integrity protection
- `.cursor/rules/project-architecture.mdc` - Project architecture
- `.cursor/rules/unreal-engine-cpp.mdc` - C++ conventions for Unreal Engine
- `memorias/erros-comuns-para-evitar.md` - Common errors to avoid

---

**This rule has MAXIMUM priority over all other rules.**
