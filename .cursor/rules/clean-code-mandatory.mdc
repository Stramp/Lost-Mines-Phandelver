---
description: CRITICAL RULE - Clean Code and Design Patterns are MANDATORY in ALL situations
globs: ["*.cpp", "*.h", "*.hpp", "*.cs"]
alwaysApply: true
---

# âš ï¸ CRITICAL RULE - CLEAN CODE AND DESIGN PATTERNS MANDATORY âš ï¸

## ğŸš¨ REGRA ZERO - VALIDAÃ‡ÃƒO PRÃ‰-CÃ“DIGO OBRIGATÃ“RIA ğŸš¨

**ANTES de escrever QUALQUER funÃ§Ã£o, SEMPRE verificar:**

1. **Esta funÃ§Ã£o pode ser reutilizada?** â†’ Vai para `Utils/` ou `Helpers/`
2. **Esta funÃ§Ã£o Ã© pura (sem side effects)?** â†’ Pode ser helper
3. **Esta funÃ§Ã£o estÃ¡ no lugar certo?** â†’ Motor sÃ³ tem lÃ³gica de motor, nÃ£o helpers
4. **Esta funÃ§Ã£o segue Single Responsibility?** â†’ Uma funÃ§Ã£o = uma responsabilidade
5. **Esta funÃ§Ã£o estÃ¡ testÃ¡vel isoladamente?** â†’ Se nÃ£o, refatorar

**ğŸš¨ REGRA CRÃTICA DE LOCALIZAÃ‡ÃƒO:**

- **MOTOR NÃƒO TEM HELPERS** - Motores (`*Motor.cpp`) sÃ³ contÃªm lÃ³gica de motor
- **VALIDATOR NÃƒO TEM HELPERS** - Validators sÃ³ validam
- **UPDATER NÃƒO TEM HELPERS** - Updaters sÃ³ atualizam
- **HELPERS NÃƒO TEM LÃ“GICA DE MOTOR** - Helpers sÃ£o funÃ§Ãµes puras e reutilizÃ¡veis

**Se a funÃ§Ã£o pode ser helper â†’ CRIAR EM Helpers/, NÃƒO no arquivo atual**

## ğŸš¨ ABSOLUTE RULE - NO EXCEPTIONS ğŸš¨

**ALWAYS, ALWAYS, ALWAYS** apply Clean Code and C++ Design Patterns in **ALL** situations:

- âœ… Production code
- âœ… Quick tests
- âœ… Prototypes
- âœ… Bug fixes
- âœ… Refactoring
- âœ… New features
- âœ… Any line of code written

**NEVER, NEVER, NEVER** create code that violates Clean Code or Design Patterns, even if it's:

- âŒ "Just a quick test"
- âŒ "I'll fix it later"
- âŒ "It's temporary"
- âŒ "It works like this"

## MANDATORY Principles

### 1. Helper/Utility Functions

**CRITICAL RULE:** Any function that can be reused MUST be in a separate helpers/utilities file.

**ğŸš¨ REGRA DE LOCALIZAÃ‡ÃƒO ABSOLUTA:**

- âŒ **NUNCA** criar helper dentro de `*Motor.cpp` (ex: `MulticlassMotor.cpp`, `PointBuyMotor.cpp`)
- âŒ **NUNCA** criar helper dentro de `*Validator.cpp` (ex: `PointBuyValidator.cpp`)
- âŒ **NUNCA** criar helper dentro de `*Updater.cpp`
- âœ… **SEMPRE** criar helper em `*Helpers.h/cpp` correspondente (ex: `MulticlassHelpers.h`)

**ALWAYS:**

- âœ… Helper functions in `Utils/` or `Helpers/`
- âœ… Parameterized functions (without internal state dependency)
- âœ… Pure functions when possible
- âœ… Functions testable in isolation
- âœ… Static functions in helper classes/namespaces

**NEVER:**

- âŒ Helper functions inside Motor/Validator/Updater files
- âŒ Helper functions inside classes when they can be reused
- âŒ Functions coupled to internal state when they can be parameterized
- âŒ Duplication of search/verification code
- âŒ "Local helper" functions that could be reused

**CRITICAL RULE - Namespace Helpers:**

**ALWAYS** verify if a helper function in an anonymous `namespace` can be separated:

- âœ… **If helper can be reused or tested separately** â†’ Move to `Helpers/` or `Utils/` file
- âœ… **If helper is pure/parameterized** â†’ MUST be in separate file
- âœ… **If helper is only used by one function** â†’ Still move to `Helpers/` if it can be tested/validated separately

**NEVER:**

- âŒ Create anonymous `namespace` helpers in core/motor files when they can be separated
- âŒ Keep helpers in core files "just because they're only used once"
- âŒ Mix helper logic with orchestration/flow logic in the same file

**CORRECT Example:**

```cpp
// MulticlassHelpers.h
class FMulticlassHelpers {
public:
    static FMulticlassProficienciesEntry ConvertProficienciesEntry(const FProficienciesEntry &SourceEntry);
};

// MulticlassMotor.cpp (core - only orchestration)
bool FMulticlassMotor::LoadClassProficiencies(...)
{
    // ... validation ...
    FMulticlassProficienciesEntry ConvertedEntry = FMulticlassHelpers::ConvertProficienciesEntry(SourceEntry);
    // ... orchestration ...
}
```

**WRONG Example:**

```cpp
// âŒ NEVER do this - helper in core file
namespace {
    FMulticlassProficienciesEntry ConvertProficienciesEntry(...) { ... }
}

bool FMulticlassMotor::LoadClassProficiencies(...)
{
    // Uses helper from anonymous namespace
}
```

**CORRECT Example:**

```cpp
// Utils/ComponentHelpers.h
UCharacterDataComponent* FindCharacterDataComponent(AActor* Owner);

// Utils/ComponentHelpers.cpp
UCharacterDataComponent* FindCharacterDataComponent(AActor* Owner)
{
    if (!Owner) return nullptr;
    return Owner->FindComponentByClass<UCharacterDataComponent>();
}
```

**WRONG Example:**

```cpp
// âŒ NEVER do this - private function coupled
private:
    UCharacterDataComponent* FindOrGetCharacterDataComponent()
    {
        if (!CharacterDataComponent)
        {
            CharacterDataComponent = GetOwner()->FindComponentByClass<UCharacterDataComponent>();
        }
        return CharacterDataComponent;
    }
```

### 2. DRY (Don't Repeat Yourself)

**CRITICAL RULE:** If you're going to use the same logic in more than one place, create a helper function.

**ALWAYS:**

- âœ… Identify duplicated code
- âœ… Extract to helper function
- âœ… Parameterize appropriately

**NEVER:**

- âŒ Copy and paste code
- âŒ "Just this once I'll duplicate"

### 3. Single Responsibility Principle (SRP)

**CRITICAL RULE:** Each function/class must have a single responsibility.

**ALWAYS:**

- âœ… Small, focused functions
- âœ… One function = one action
- âœ… Classes with single responsibility

**NEVER:**

- âŒ Functions that do multiple things
- âŒ Classes that do everything

### 4. Separation of Concerns

**CRITICAL RULE:** Separate business logic from auxiliary logic.

**ALWAYS:**

- âœ… Helpers in separate files
- âœ… Utilities in `Utils/`
- âœ… Pure functions when possible

**NEVER:**

- âŒ Mix helpers with business logic
- âŒ Couple utility functions to specific classes

### 5. Testability

**CRITICAL RULE:** Code must be testable.

**ALWAYS:**

- âœ… Parameterized functions
- âœ… No hidden dependencies
- âœ… Pure functions when possible

**NEVER:**

- âŒ Functions coupled to global state
- âŒ Hardcoded dependencies

## MANDATORY Checklist

**BEFORE writing ANY code, ALWAYS ask (in this order):**

1. **[ ] Esta funÃ§Ã£o pode ser reutilizada?** â†’ Se SIM, vai para `Utils/` ou `Helpers/`
2. **[ ] Esta funÃ§Ã£o Ã© pura (sem side effects)?** â†’ Se SIM, pode ser helper
3. **[ ] Esta funÃ§Ã£o estÃ¡ no arquivo correto?**
   - Motor? â†’ SÃ³ lÃ³gica de motor, SEM helpers
   - Validator? â†’ SÃ³ validaÃ§Ã£o, SEM helpers
   - Updater? â†’ SÃ³ atualizaÃ§Ã£o, SEM helpers
   - Helper? â†’ SÃ³ funÃ§Ãµes puras, SEM lÃ³gica de motor
4. **[ ] Esta funÃ§Ã£o depende de estado interno?** â†’ Pode ser parameterizada?
5. **[ ] Estou duplicando cÃ³digo?** â†’ Extrair para helper
6. **[ ] Esta funÃ§Ã£o tem single responsibility?** â†’ Uma funÃ§Ã£o = uma aÃ§Ã£o
7. **[ ] Esta funÃ§Ã£o Ã© testÃ¡vel isoladamente?** â†’ Se nÃ£o, refatorar
8. **[ ] Estou seguindo Clean Code?** â†’ Verificar todos os princÃ­pios
9. **[ ] Estou seguindo Design Patterns apropriados?** â†’ Verificar padrÃµes

**Se QUALQUER resposta indicar que deve ser helper â†’ PARAR e criar em Helpers/**

## Helpers/Utils Structure

**ALWAYS** organize helpers in:

```text
Source/MyProject2/
â”œâ”€â”€ Utils/
â”‚   â”œâ”€â”€ ComponentHelpers.h
â”‚   â”œâ”€â”€ ComponentHelpers.cpp
â”‚   â”œâ”€â”€ MathHelpers.h
â”‚   â”œâ”€â”€ MathHelpers.cpp
â”‚   â””â”€â”€ ...
```

## When to Create Helper

**ALWAYS** create helper when:

1. âœ… Function can be used in more than one place
2. âœ… Function is pure (no side effects)
3. âœ… Function does generic search/verification
4. âœ… Function does calculation/transformation
5. âœ… Function can be tested in isolation

## Exceptions

**THERE ARE NO EXCEPTIONS.** This rule is absolute.

## Final Reminder

**EVERY** line of code must follow Clean Code and Design Patterns.

**NEVER** create "temporary" or "just for testing" code that violates these rules.

**ALWAYS** think about reusability, testability, and maintainability.

---

## ğŸ“š ReferÃªncias de DocumentaÃ§Ã£o

**Sempre consultar estas referÃªncias ao aplicar Clean Code e Design Patterns:**

### Clean Code
- **PrincÃ­pios fundamentais**: FunÃ§Ãµes pequenas, nomes descritivos, responsabilidade Ãºnica
- **DRY (Don't Repeat Yourself)**: Eliminar duplicaÃ§Ã£o de cÃ³digo
- **Separation of Concerns**: Separar lÃ³gica de negÃ³cio de lÃ³gica auxiliar
- **Testability**: CÃ³digo deve ser testÃ¡vel isoladamente

### C++ Design Patterns
- **Strategy Pattern**: Para algoritmos intercambiÃ¡veis
- **Factory Pattern**: Para criaÃ§Ã£o de objetos
- **Observer Pattern**: Para eventos e notificaÃ§Ãµes
- **RAII (Resource Acquisition Is Initialization)**: Gerenciamento automÃ¡tico de recursos
- **Guard Pattern**: Para garantir limpeza de recursos (ex: `FValidationGuard`)

### Unreal Engine 5.7
- **UPROPERTY/UFUNCTION**: Macros para expor propriedades e funÃ§Ãµes ao Blueprint
- **USTRUCT**: Para estruturas de dados
- **Component-Based Architecture**: Separar funcionalidades em componentes
- **Data-Driven Design**: Usar Data Tables e Data Assets ao invÃ©s de hardcode
- **Replication**: Preparar cÃ³digo para multiplayer desde o inÃ­cio

### Regras Relacionadas
- `.cursor/rules/clean-code-mandatory.mdc` - Esta regra (mÃ¡xima prioridade)
- `.cursor/rules/test-driven-development.mdc` - TDD obrigatÃ³rio para cÃ³digo crÃ­tico
- `.cursor/rules/execution-guard.mdc` - ProteÃ§Ã£o de integridade do projeto
- `.cursor/rules/project-architecture.mdc` - Arquitetura do projeto
- `.cursor/rules/unreal-engine-cpp.mdc` - ConvenÃ§Ãµes C++ para Unreal Engine
- `memorias/erros-comuns-para-evitar.md` - Erros comuns para nÃ£o repetir

---

**This rule has MAXIMUM priority over all other rules.**
